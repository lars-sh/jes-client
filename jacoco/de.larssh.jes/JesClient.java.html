<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JesClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JES Client</a> &gt; <a href="index.source.html" class="el_package">de.larssh.jes</a> &gt; <span class="el_source">JesClient.java</span></div><h1>JesClient.java</h1><pre class="source lang-java linenums">// Generated by delombok at Fri Jun 21 17:19:46 UTC 2024
package de.larssh.jes;

import static de.larssh.utils.Collectors.toLinkedHashMap;
import static de.larssh.utils.Finals.constant;
import static de.larssh.utils.function.ThrowingFunction.throwing;
import static java.util.Arrays.asList;
import static java.util.Arrays.stream;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.io.input.ReaderInputStream;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;
import de.larssh.jes.parser.JesFtpFile;
import de.larssh.jes.parser.JesFtpFileEntryParserFactory;
import de.larssh.utils.Nullables;
import de.larssh.utils.Optionals;
import de.larssh.utils.annotations.SuppressJacocoGenerated;
import de.larssh.utils.function.ThrowingConsumer;
import de.larssh.utils.text.Patterns;
import de.larssh.utils.text.Strings;
import de.larssh.utils.time.Stopwatch;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class allows to handle IBM z/OS JES spools using Java technologies. The
 * used interface is the IBM z/OS FTP server, that should be available by
 * default.
 *
 * &lt;p&gt;
 * JES spool entries can be filtered and listed using
 * {@link #list(String, JobStatus, String)} and
 * {@link #listFilled(String, JobStatus, String)} methods, while the later one
 * gathers more information, but takes some more time.
 *
 * &lt;p&gt;
 * {@link #submit(String)} submits JCLs based on the FTP users permissions.
 * {@link #waitFor(Job, Duration, Duration)} can be used to wait until a job
 * terminates. Job outputs can be retrieved using {@link #retrieve(JobOutput)}
 * and removed using {@link #delete(Job)}.
 *
 * &lt;p&gt;
 * &lt;b&gt;Usage example:&lt;/b&gt; The following shows the JesClient used inside a
 * try-with-resource statement. The constructor descriptions describe further
 * details.
 *
 * &lt;pre&gt;
 * // Connect and login via simplified constructor
 * try (JesClient jesClient = new JesClient(hostname, port, username, password)) {
 *
 *     // Submit JCL
 *     Job job = jesClient.submit(jclContent);
 *
 *     // Wait for job to be finished
 *     if (!jesClient.waitFor(job)) {
 *         // Handle the case, a finished job cannot be found inside JES spool any longer
 *         throw ...;
 *     }
 *
 *     // Gather job status details
 *     Job detailedJob = jesClient.getJobDetails(job);
 *
 *     // Gather finished jobs outputs
 *     List&amp;lt;JobOutput&amp;gt; jobOutput = jesClient.get(job);
 *
 *     // Delete job from JES spool
 *     jesClient.delete(job);
 *
 * // Logout and disconnect using try-with-resource (close method)
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * In case filtering jobs does not work as expected, check the JES Interface
 * Level of your server using {@link #getServerProperties()}. This class
 * requires {@code JESINTERFACELEVEL = 2}. The JES Interface Level can be
 * configured by a mainframe administrator inside {@code FTP.DATA}.
 *
 * @see &lt;a href=
 *      &quot;https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.halu001/intfjes.htm&quot;&gt;IBM
 *      Knowledge Center - Interfacing with JES&lt;/a&gt;
 */
@SuppressWarnings({&quot;PMD.ExcessiveImports&quot;, &quot;PMD.GodClass&quot;})
public class JesClient implements Closeable {
	/**
	 * Wildcard value to be used for name and owner filters, meaning &quot;any&quot; value.
	 */
<span class="fc" id="L106">	public static final String FILTER_WILDCARD = constant(&quot;*&quot;);</span>
	/**
	 * Charset, that is used for submitting JCLs and retrieving job outputs.
	 */
<span class="fc" id="L110">	private static final Charset FTP_DATA_CHARSET = StandardCharsets.UTF_8;</span>
	/**
	 * Maximum limit of spool entries (including)
	 */
<span class="fc" id="L114">	public static final int LIST_LIMIT_MAX = constant(1024);</span>
	/**
	 * Limit of spool entries for {@link #exists(Job, JobStatus)}
	 *
	 * &lt;p&gt;
	 * Checking for existence does not need a limit, but using a limit allows to
	 * handle an additional error case.
	 */
	private static final int LIST_LIMIT_EXISTS = 2;
	/**
	 * Minimum limit of spool entries (including)
	 */
	private static final int LIST_LIMIT_MIN = 1;
	/**
	 * Pattern to find the job ID inside the FTP response after submitting a JCL.
	 */
<span class="fc" id="L130">	private static final Pattern PATTERN_FTP_SUBMIT_ID = Pattern.compile(&quot;^250-IT IS KNOWN TO JES AS (?&lt;id&gt;\\S+)&quot;, Pattern.CASE_INSENSITIVE);</span>
	/**
	 * Pattern to find the job name inside a valid JCL.
	 */
<span class="fc" id="L134">	private static final Pattern PATTERN_JCL_JOB_NAME = Pattern.compile(&quot;^//\\s*(?&lt;name&gt;\\S+)&quot;);</span>
	/**
	 * Pattern to check the response string for the spool entries limit warning.
	 */
<span class="fc" id="L138">	private static final Pattern PATTERN_LIST_LIMIT = Pattern.compile(&quot;^250-JESENTRYLIMIT OF \\d+ REACHED\\. +ADDITIONAL ENTRIES NOT DISPLAYED$&quot;, Pattern.CASE_INSENSITIVE);</span>
	/**
	 * Pattern to check the response string for the empty list warning.
	 */
<span class="fc" id="L142">	private static final Pattern PATTERN_LIST_NAMES_NO_JOBS_FOUND = Pattern.compile(&quot;^550 NO JOBS FOUND FOR &quot;, Pattern.CASE_INSENSITIVE);</span>
	/**
	 * Pattern to retrieve status values from response strings.
	 */
<span class="fc" id="L146">	private static final Pattern PATTERN_STATUS = Pattern.compile(&quot;^211-(SERVER SITE VARIABLE |TIMER )?(?&lt;key&gt;\\S+)( VALUE)? IS (SET TO )?(?&lt;value&gt;\\S+?)\\.?$&quot;, Pattern.CASE_INSENSITIVE);</span>
	/**
	 * Remote file name that is used when submitting a JCL.
	 */
<span class="fc" id="L150">	private static final String SUBMIT_REMOTE_FILE_NAME = JesClient.class.getSimpleName() + &quot;.jcl&quot;;</span>
	/**
	 * FTP Client used by the current JES client instance.
	 */
	private final FTPClient ftpClient;
	/**
	 * Current JES spool user
	 */
<span class="fc" id="L158">	private String jesOwner = FILTER_WILDCARD;</span>

	/**
	 * Expert constructor. This constructor creates a FTP client &lt;b&gt;without&lt;/b&gt;
	 * connecting and logging in. It is meant to be used in scenarios, which require
	 * additional FTP configuration.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Usage example 1&lt;/b&gt; (using a simplified login)
	 *
	 * &lt;pre&gt;
	 * // Construct the JES client and its internal FTP client
	 * try (JesClient jesClient = new JesClient()) {
	 *
	 *     // Connect via FTP
	 *     jesClient.getFtpClient().connect(...);
	 *
	 *     // Simplified login using the JES client
	 *     jesClient.login(...);
	 *
	 *     ...
	 *
	 * // Logout and disconnect using try-with-resource (close method)
	 * }
	 * &lt;/pre&gt;
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Usage example 2:&lt;/b&gt; (using a custom login)
	 *
	 * &lt;pre&gt;
	 * // Construct the JES client and its internal FTP client
	 * try (JesClient jesClient = new JesClient()) {
	 *
	 *     // Connect via FTP
	 *     jesClient.getFtpClient().connect(...);
	 *
	 *     // Login via FTP client
	 *     jesClient.getFtpClient().login(...);
	 *
	 *     // Set the JES spool owner
	 *     jesClient.setJesOwner(...);
	 *
	 *     // Enter JES mode of the FTP connection
	 *     jesClient.enterJesMode();
	 *
	 *     ...
	 *
	 * // Logout and disconnect using try-with-resource (close method)
	 * }
	 * &lt;/pre&gt;
	 */
<span class="fc" id="L209">	public JesClient() {</span>
<span class="fc" id="L210">		ftpClient = new FTPClient();</span>
<span class="fc" id="L211">		ftpClient.setParserFactory(new JesFtpFileEntryParserFactory());</span>
<span class="fc" id="L212">	}</span>

	/**
	 * Simplified constructor. This constructor initiates a new FTP connection and
	 * logs in using the given credentials.
	 *
	 * &lt;p&gt;
	 * The JesClient can store a JES spool owner. This constructor initializes the
	 * JES spool owner using the given username.
	 *
	 * &lt;p&gt;
	 * The default port is {@link org.apache.commons.net.ftp.FTP#DEFAULT_PORT}.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Warning:&lt;/b&gt; This constructor calls the overridable method
	 * {@link #login(String, String)}, which might lead to uninitialized fields when
	 * overriding that method.
	 *
	 * @param hostname FTP hostname
	 * @param port     FTP port
	 * @param username FTP username and JES spool owner
	 * @param password FTP password
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	@SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)
	@SuppressJacocoGenerated(justification = &quot;this constructor cannot be mocked nicely&quot;)
	@SuppressFBWarnings(value = {&quot;CT_CONSTRUCTOR_THROW&quot;, &quot;PCOA_PARTIALLY_CONSTRUCTED_OBJECT_ACCESS&quot;}, justification = &quot;see JavaDoc&quot;)
	public JesClient(final String hostname, final int port, final String username, final String password) throws IOException, JesException {
		this();
		ftpClient.connect(hostname, port);
		login(username, password);
	}

	/**
	 * Logs out and disconnects the FTP connection.
	 */
	@Override
	public void close() throws IOException {
		try {
<span class="fc bfc" id="L252" title="All 2 branches covered.">			if (getFtpClient().isAvailable()) {</span>
<span class="fc" id="L253">				getFtpClient().logout();</span>
			}
		} finally {
<span class="fc bfc" id="L256" title="All 2 branches covered.">			if (getFtpClient().isConnected()) {</span>
<span class="fc" id="L257">				getFtpClient().disconnect();</span>
			}
		}
<span class="fc" id="L260">	}</span>

	/**
	 * Removes a given {@code job} from JES spool. This method cares only about the
	 * jobs ID.
	 *
	 * &lt;p&gt;
	 * In case you do not already have a {@link Job} object, deleting by job ID
	 * works as follows:
	 *
	 * &lt;pre&gt;
	 * String jobId = ...;
	 * jesClient.delete(new Job(jobId, JesClient.FILTER_WILDCARD, JobStatus.ALL, JesClient.FILTER_WILDCARD));
	 * &lt;/pre&gt;
	 *
	 * @param job Job to be deleted
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public void delete(final Job job) throws IOException, JesException {
<span class="fc bfc" id="L280" title="All 2 branches covered.">		if (!getFtpClient().deleteFile(job.getId())) {</span>
<span class="fc" id="L281">			throw new JesException(getFtpClient(), &quot;Job [%s] could not be deleted.&quot;, job.getId());</span>
		}
<span class="fc" id="L283">	}</span>

	/**
	 * Enters the IBM z/OS FTP servers JES file type mode using a SITE command.
	 *
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public void enterJesMode() throws IOException, JesException {
<span class="fc bfc" id="L292" title="All 2 branches covered.">		if (!getFtpClient().sendSiteCommand(&quot;FILEtype=JES&quot;)) {</span>
<span class="fc" id="L293">			throw new JesException(getFtpClient(), &quot;Failed setting JES mode.&quot;);</span>
		}
<span class="fc" id="L295">	}</span>

	/**
	 * Reloads the job from server and returns {@code true} if the job is still
	 * available and matches the given job status.
	 *
	 * @param job    the job to search for
	 * @param status job status or ALL
	 * @return {@code true} if the job is still available
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public boolean exists(final Job job, final JobStatus status) throws IOException, JesException {
<span class="fc" id="L308">		setJesFilters(job.getName(), status, job.getOwner(), LIST_LIMIT_EXISTS);</span>
<span class="fc" id="L309">		final String[] ids = getListNameResults(getFtpClient().listNames(job.getId())).orElseThrow(() -&gt; new JesException(getFtpClient(), &quot;Retrieving job [%s] failed. Probably no FTP data connection socket could be opened.&quot;, job.getId()));</span>
<span class="fc" id="L310">		return Optionals.ofSingle(ids).isPresent();</span>
	}

	/**
	 * Retrieves up-to-date job details for {@code job}. That includes all
	 * {@link Job} attributes, including a list of {@link JobOutput} instances for
	 * held jobs.
	 *
	 * @param job job to get up-to-date details for
	 * @return job details or {@link Optional#empty()} in case the job is no longer
	 *         available inside JES spool
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public Optional&lt;Job&gt; getJobDetails(final Job job) throws IOException, JesException {
<span class="fc" id="L325">		setJesFilters(job.getName(), JobStatus.ALL, job.getOwner(), LIST_LIMIT_MAX);</span>
<span class="fc" id="L326">		return Optionals.ofSingle( //</span>
<span class="fc" id="L327">		stream(getFtpClient().listFiles(job.getId())).filter(JesFtpFile.class::isInstance).map(JesFtpFile.class::cast).map(JesFtpFile::getJob));</span>
	}

	/**
	 * Corrects the result of {@link FTPClient#listNames()} and
	 * {@link FTPClient#listNames(String)} as the mainframe FTP server marks empty
	 * name listings as error.
	 *
	 * @param names result of {@link FTPClient#listNames()} and
	 *              {@link FTPClient#listNames(String)}
	 * @return array of names or {@link Optional#empty()} on real FTP error
	 */
	@SuppressWarnings(&quot;PMD.UseVarargs&quot;)
	@SuppressFBWarnings(value = &quot;UVA_USE_VAR_ARGS&quot;, justification = &quot;No varargs needed as this is for special technical reasons only.&quot;)
	private Optional&lt;String[]&gt; getListNameResults(@Nullable final String[] names) {
<span class="fc bfc" id="L342" title="All 2 branches covered.">		if (names == null) {</span>
<span class="fc" id="L343">			return Patterns.find(PATTERN_LIST_NAMES_NO_JOBS_FOUND, getFtpClient().getReplyString()).map(matcher -&gt; new String[0]);</span>
		}
<span class="fc" id="L345">		return Optional.of(names);</span>
	}

	/**
	 * Retrieves and parses a map of server properties, such as
	 * {@code &quot;JESJOBNAME&quot;}, {@code &quot;JESSTATUS&quot;}, {@code &quot;JESOWNER&quot;} and
	 * {@code &quot;INTERFACELEVEL&quot;}.
	 *
	 * @return map of server properties
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public Map&lt;String, String&gt; getServerProperties() throws IOException, JesException {
		// Execute STAT command
<span class="fc bfc" id="L359" title="All 2 branches covered.">		if (!FTPReply.isPositiveCompletion(getFtpClient().stat())) {</span>
<span class="fc" id="L360">			throw new JesException(getFtpClient(), &quot;Failed executing STAT command.&quot;);</span>
		}
<span class="fc" id="L362">		final String[] lines = getFtpClient().getReplyStrings();</span>
		// Parse reply strings
<span class="fc" id="L364">		final Map&lt;String, String&gt; properties = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">		for (final String line : lines) {</span>
<span class="fc" id="L366">			final Optional&lt;Matcher&gt; matcher = Patterns.matches(PATTERN_STATUS, line);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">			if (matcher.isPresent()) {</span>
				// Key
<span class="fc" id="L369">				final String key = matcher.get().group(&quot;key&quot;);</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">				if (properties.containsKey(key)) {</span>
<span class="fc" id="L371">					throw new JesException(&quot;Found duplicate status key \&quot;%s\&quot;.&quot;, key);</span>
				}
				// Value
<span class="fc" id="L374">				properties.put(key, matcher.get().group(&quot;value&quot;));</span>
			}
		}
<span class="fc" id="L377">		return properties;</span>
	}

	/**
	 * Returns a list of all job IDs boxed into {@link Job} objects matching the
	 * given filters. This method has a much higher performance compared to
	 * {@link #listFilled(String)}, though that method fills in additional
	 * {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} is allowed to end with the wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@link #LIST_LIMIT_MAX} entries. In case more
	 * entries are available, a {@link JesLimitReachedException} is thrown,
	 * containing all entries up to the limit.
	 *
	 * @param nameFilter filter by job names
	 * @return list of jobs containing job IDs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; list(final String nameFilter) throws IOException, JesException {
<span class="fc" id="L400">		return list(nameFilter, JobStatus.ALL);</span>
	}

	/**
	 * Returns a list of all job IDs boxed into {@link Job} objects matching the
	 * given filters. This method has a much higher performance compared to
	 * {@link #listFilled(String, JobStatus)}, though that method fills in
	 * additional {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} is allowed to end with the wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@link #LIST_LIMIT_MAX} entries. In case more
	 * entries are available, a {@link JesLimitReachedException} is thrown,
	 * containing all entries up to the limit.
	 *
	 * @param nameFilter filter by job names
	 * @param status     filter by job status
	 * @return list of jobs containing job IDs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; list(final String nameFilter, final JobStatus status) throws IOException, JesException {
<span class="fc" id="L424">		return list(nameFilter, status, FILTER_WILDCARD);</span>
	}

	/**
	 * Returns a list of all job IDs boxed into {@link Job} objects matching the
	 * given filters. This method has a much higher performance compared to
	 * {@link #listFilled(String, JobStatus, String)}, though that method fills in
	 * additional {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} and {@code ownerFilter} are allowed to end with the
	 * wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@link #LIST_LIMIT_MAX} entries. In case more
	 * entries are available, a {@link JesLimitReachedException} is thrown,
	 * containing all entries up to the limit.
	 *
	 * @param nameFilter  filter by job names
	 * @param status      filter by job status
	 * @param ownerFilter filter by job owner
	 * @return list of jobs containing job IDs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; list(final String nameFilter, final JobStatus status, final String ownerFilter) throws IOException, JesException {
<span class="fc" id="L450">		return list(nameFilter, status, ownerFilter, LIST_LIMIT_MAX);</span>
	}

	/**
	 * Returns a list of all job IDs boxed into {@link Job} objects matching the
	 * given filters. This method has a much higher performance compared to
	 * {@link #listFilled(String, JobStatus, String, int)}, though that method fills
	 * in additional {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} and {@code ownerFilter} are allowed to end with the
	 * wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@code limit} entries. In case more entries are
	 * available, a {@link JesLimitReachedException} is thrown, containing all
	 * entries up to the limit. {@code limit} can be from {@link #LIST_LIMIT_MIN}
	 * (including) to {@link #LIST_LIMIT_MAX} (including).
	 *
	 * @param nameFilter  filter by job names
	 * @param status      filter by job status
	 * @param ownerFilter filter by job owner
	 * @param limit       limit of spool entries
	 * @return list of jobs containing job IDs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; list(final String nameFilter, final JobStatus status, final String ownerFilter, final int limit) throws IOException, JesException {
<span class="fc" id="L478">		setJesFilters(nameFilter, status, ownerFilter, limit);</span>
<span class="fc" id="L479">		final String[] ids = getListNameResults(getFtpClient().listNames()).orElseThrow(() -&gt; new JesException(getFtpClient(), &quot;Retrieving the list of job IDs failed. Probably no FTP data connection socket could be opened.&quot;));</span>
<span class="fc" id="L480">		return throwIfLimitReached(limit, stream(ids).map(id -&gt; new Job(id, nameFilter, status, ownerFilter)).collect(toList()));</span>
	}

	/**
	 * Returns a list of all {@link Job} objects matching the given filters. This
	 * method has a worse performance compared to {@link #list(String)}, though it
	 * fills in additional {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} is allowed to end with the wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@link #LIST_LIMIT_MAX} entries. In case more
	 * entries are available, a {@link JesLimitReachedException} is thrown,
	 * containing all entries up to the limit.
	 *
	 * @param nameFilter filter by job names
	 * @return list of jobs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; listFilled(final String nameFilter) throws IOException, JesException {
<span class="fc" id="L502">		return listFilled(nameFilter, JobStatus.ALL);</span>
	}

	/**
	 * Returns a list of all {@link Job} objects matching the given filters. This
	 * method has a worse performance compared to {@link #list(String, JobStatus)},
	 * though it fills in additional {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} is allowed to end with the wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@link #LIST_LIMIT_MAX} entries. In case more
	 * entries are available, a {@link JesLimitReachedException} is thrown,
	 * containing all entries up to the limit.
	 *
	 * @param nameFilter filter by job names
	 * @param status     filter by job status
	 * @return list of jobs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; listFilled(final String nameFilter, final JobStatus status) throws IOException, JesException {
<span class="fc" id="L525">		return listFilled(nameFilter, status, FILTER_WILDCARD);</span>
	}

	/**
	 * Returns a list of all {@link Job} objects matching the given filters. This
	 * method has a worse performance compared to
	 * {@link #list(String, JobStatus, String)}, though it fills in additional
	 * {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} and {@code ownerFilter} are allowed to end with the
	 * wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@link #LIST_LIMIT_MAX} entries. In case more
	 * entries are available, a {@link JesLimitReachedException} is thrown,
	 * containing all entries up to the limit.
	 *
	 * @param nameFilter  filter by job names
	 * @param status      filter by job status
	 * @param ownerFilter filter by job owner
	 * @return list of jobs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; listFilled(final String nameFilter, final JobStatus status, final String ownerFilter) throws IOException, JesException {
<span class="fc" id="L551">		return listFilled(nameFilter, status, ownerFilter, LIST_LIMIT_MAX);</span>
	}

	/**
	 * Returns a list of all {@link Job} objects matching the given filters. This
	 * method has a worse performance compared to
	 * {@link #list(String, JobStatus, String)}, though it fills in additional
	 * {@link Job} fields.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} and {@code ownerFilter} are allowed to end with the
	 * wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * JES does not list more than {@code limit} entries. In case more entries are
	 * available, a {@link JesLimitReachedException} is thrown, containing all
	 * entries up to the limit. {@code limit} can be from {@link #LIST_LIMIT_MIN}
	 * (including) to {@link #LIST_LIMIT_MAX} (including).
	 *
	 * @param nameFilter  filter by job names
	 * @param status      filter by job status
	 * @param ownerFilter filter by job owner
	 * @param limit       limit of spool entries
	 * @return list of jobs
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public List&lt;Job&gt; listFilled(final String nameFilter, final JobStatus status, final String ownerFilter, final int limit) throws IOException, JesException {
<span class="fc" id="L579">		setJesFilters(nameFilter, status, ownerFilter, limit);</span>
<span class="fc" id="L580">		final FTPFile[] files = getFtpClient().listFiles();</span>
<span class="fc" id="L581">		return throwIfLimitReached(limit, stream(files).filter(JesFtpFile.class::isInstance).map(JesFtpFile.class::cast).map(JesFtpFile::getJob).collect(toList()));</span>
	}

	/**
	 * Shortcut method to perform a FTP login, set the internal JES owner and enter
	 * JES mode.
	 *
	 * &lt;p&gt;
	 * Is similar to the following lines of code.
	 *
	 * &lt;pre&gt;
	 * // Login via FTP client
	 * jesClient.getFtpClient().login(...);
	 *
	 * // Set the JES spool owner
	 * jesClient.setJesOwner(...);
	 *
	 * // Enter JES mode of the FTP connection
	 * jesClient.enterJesMode();
	 * &lt;/pre&gt;
	 *
	 * @param username the user id to be used for FTP login and internal JES owner
	 * @param password the users password
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public void login(final String username, final String password) throws IOException, JesException {
<span class="fc bfc" id="L608" title="All 2 branches covered.">		if (!getFtpClient().login(username, password)) {</span>
<span class="fc" id="L609">			throw new JesException(getFtpClient(), &quot;Could not login user [%s].&quot;, username);</span>
		}
<span class="fc" id="L611">		setJesOwner(username);</span>
<span class="fc" id="L612">		enterJesMode();</span>
<span class="fc" id="L613">	}</span>

	/**
	 * Retrieves the content of {@code jobOutput}.
	 *
	 * @param jobOutput job output to be requested
	 * @return content of the specified job output
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public String retrieve(final JobOutput jobOutput) throws IOException, JesException {
<span class="fc" id="L624">		final String fileName = Strings.format(&quot;%s.%d&quot;, jobOutput.getJob().getId(), jobOutput.getIndex());</span>
<span class="fc" id="L625">		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">			if (!getFtpClient().retrieveFile(fileName, outputStream)) {</span>
<span class="fc" id="L627">				throw new JesException(getFtpClient(), &quot;Could not retrieve data of job output [%s.%s].&quot;, jobOutput.getJob().getId(), jobOutput.getStep());</span>
			}
<span class="fc" id="L629">			return new String(outputStream.toByteArray(), FTP_DATA_CHARSET);</span>
		}
	}

	/**
	 * Retrieves all job outputs of {@code job}.
	 *
	 * @param job job to request all outputs of
	 * @return map with job output details and the corresponding content in specific
	 *         order
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public Map&lt;JobOutput, String&gt; retrieveOutputs(final Job job) throws IOException, JesException {
<span class="fc bfc" id="L643" title="All 2 branches covered.">		if (job.getOutputs().isEmpty()) {</span>
<span class="fc" id="L644">			return retrieveOutputs(getJobDetails(job).orElseThrow(() -&gt; new JesException(&quot;Job [%s] is not available.&quot;, job.getId())));</span>
		}
<span class="fc" id="L646">		return job.getOutputs().stream().collect(toLinkedHashMap(Function.identity(), throwing(this::retrieve)));</span>
	}

	/**
	 * Sends {@link org.apache.commons.net.ftp.FTPCmd#SITE} commands to set the
	 * given filter values.
	 *
	 * &lt;p&gt;
	 * {@code nameFilter} and {@code ownerFilter} are allowed to end with the
	 * wildcard character &quot;*&quot;.
	 *
	 * &lt;p&gt;
	 * {@code limit} can be from {@link #LIST_LIMIT_MIN} (including) to
	 * {@link #LIST_LIMIT_MAX} (including). While that restriction is not checked by
	 * this method, values outside that range might result in a server side error
	 * message thrown as {@link JesException}.
	 *
	 * @param nameFilter  filter by job names
	 * @param status      filter by job status
	 * @param ownerFilter filter by job owner
	 * @param limit       limit of spool entries
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	protected void setJesFilters(final String nameFilter, final JobStatus status, final String ownerFilter, final int limit) throws IOException, JesException {
<span class="fc bfc" id="L671" title="All 2 branches covered.">		if (!getFtpClient().sendSiteCommand(&quot;JESJOBName=&quot; + nameFilter)) {</span>
<span class="fc" id="L672">			throw new JesException(getFtpClient(), &quot;Failed setting JES job name filter to [%s].&quot;, nameFilter);</span>
		}
<span class="fc bfc" id="L674" title="All 2 branches covered.">		if (!getFtpClient().sendSiteCommand(&quot;JESOwner=&quot; + ownerFilter)) {</span>
<span class="fc" id="L675">			throw new JesException(getFtpClient(), &quot;Failed setting JES job owner filter to [%s].&quot;, ownerFilter);</span>
		}
<span class="fc bfc" id="L677" title="All 2 branches covered.">		if (!getFtpClient().sendSiteCommand(&quot;JESSTatus=&quot; + status.getValue())) {</span>
<span class="fc" id="L678">			throw new JesException(getFtpClient(), &quot;Failed setting JES job status filter to [%s].&quot;, status.getValue());</span>
		}
<span class="fc bfc" id="L680" title="All 2 branches covered.">		if (!getFtpClient().sendSiteCommand(&quot;JESENTRYLIMIT=&quot; + limit)) {</span>
<span class="fc" id="L681">			throw new JesException(getFtpClient(), &quot;Failed setting JES entry limit to %d. Minimum/Maximum: %d/%d&quot;, limit, LIST_LIMIT_MIN, LIST_LIMIT_MAX);</span>
		}
<span class="fc" id="L683">	}</span>

	/**
	 * Current JES spool user
	 *
	 * @param jesOwner JES spool owner
	 */
	public void setJesOwner(final String jesOwner) {
<span class="fc" id="L691">		this.jesOwner = Strings.toUpperCaseNeutral(jesOwner).trim();</span>
<span class="fc" id="L692">	}</span>

	/**
	 * Submits the given JCL and returns a related {@link Job} object containing the
	 * started jobs ID.
	 *
	 * &lt;p&gt;
	 * In addition to the jobs ID this method tries to extract the jobs name from
	 * the given JCL. The returned owner is set to the internal JES owner, which can
	 * be set using {@link #setJesOwner(String)}.
	 *
	 * @param jclContent JCL to submit
	 * @return {@link Job} object containing the started jobs ID
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public Job submit(final String jclContent) throws IOException, JesException {
<span class="fc" id="L709">		try (InputStream inputStream = ReaderInputStream.builder().setReader(new StringReader(jclContent)).setCharset(FTP_DATA_CHARSET).get()) {</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">			if (!getFtpClient().storeUniqueFile(SUBMIT_REMOTE_FILE_NAME, inputStream)) {</span>
<span class="fc" id="L711">				throw new JesException(getFtpClient(), &quot;Submitting JCL failed.&quot;);</span>
			}
		}
<span class="fc" id="L714">		final String jobId = Patterns.find(PATTERN_FTP_SUBMIT_ID, getFtpClient().getReplyString()).map(matcher -&gt; matcher.group(&quot;id&quot;)).orElseThrow(() -&gt; new JesException(getFtpClient(), &quot;Started job, but could not extract its ID.&quot;));</span>
<span class="fc" id="L715">		final String name = Patterns.find(PATTERN_JCL_JOB_NAME, jclContent).map(matcher -&gt; matcher.group(&quot;name&quot;)).orElse(FILTER_WILDCARD);</span>
<span class="fc" id="L716">		return new Job(jobId, name, JobStatus.INPUT, getJesOwner());</span>
	}

	/**
	 * In case the last FTP responses string contains the spool entries limit
	 * warning, a {@link JesLimitReachedException} is thrown, else {@code jobs} are
	 * returned.
	 *
	 * &lt;p&gt;
	 * The thrown exception contains the current spool entries limit and all
	 * entries, which were read already.
	 *
	 * @param limit current spool entries limit
	 * @param jobs  list of jobs
	 * @return {@code jobs} in case the spool entries limit is not reached
	 * @throws JesLimitReachedException if the last FTP responses string contains
	 *                                  the spool entries limit warning
	 */
	protected List&lt;Job&gt; throwIfLimitReached(final int limit, final List&lt;Job&gt; jobs) throws JesLimitReachedException {
<span class="fc bfc" id="L735" title="All 2 branches covered.">		if (Strings.find(getFtpClient().getReplyString(), PATTERN_LIST_LIMIT)) {</span>
<span class="fc" id="L736">			throw new JesLimitReachedException(limit, jobs, getFtpClient());</span>
		}
<span class="fc" id="L738">		return jobs;</span>
	}

	/**
	 * Waits for {@code job} to be finished using {@code Thread#sleep(long)} for
	 * waiting between {@link #exists(Job, JobStatus)} calls and timing out after a
	 * given duration. {@code waiting} allows to specify the duration to wait.
	 *
	 * &lt;p&gt;
	 * The given jobs status specifies, which status are waited for:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link JobStatus#ALL}: waiting for {@link JobStatus#INPUT} and
	 * {@link JobStatus#ACTIVE}
	 * &lt;li&gt;{@link JobStatus#INPUT}: waiting for {@link JobStatus#INPUT} and
	 * {@link JobStatus#ACTIVE}
	 * &lt;li&gt;{@link JobStatus#ACTIVE}: waiting for {@link JobStatus#ACTIVE} only
	 * &lt;li&gt;{@link JobStatus#OUTPUT}: returning {@code true} with no checks and
	 * without waiting
	 * &lt;/ul&gt;
	 *
	 * @param job     the job to wait for
	 * @param waiting duration to wait
	 * @param timeout timeout duration
	 * @return {@code true} if the job finished and {@code false} if the timeout has
	 *         been reached
	 * @throws InterruptedException if any thread has interrupted the current thread
	 * @throws IOException          Technical FTP failure
	 * @throws JesException         Logical JES failure
	 */
	@SuppressWarnings({&quot;unused&quot;, &quot;PMD.DoNotUseThreads&quot;})
	public boolean waitFor(final Job job, final Duration waiting, final Duration timeout) throws InterruptedException, IOException, JesException {
<span class="fc" id="L769">		return waitFor(job, waiting, timeout, ThrowingConsumer.throwing(duration -&gt; Thread.sleep(Nullables.orElseThrow(duration).toMillis())));</span>
	}

	/**
	 * Waits for {@code job} to be finished using {@code wait} for waiting between
	 * {@link #exists(Job, JobStatus)} calls and timing out after a given duration.
	 * {@code waiting} allows to specify the duration to wait.
	 *
	 * &lt;p&gt;
	 * The given jobs status specifies, which status are waited for:
	 * &lt;ul&gt;
	 * &lt;li&gt;{@link JobStatus#ALL}: waiting for {@link JobStatus#INPUT} and
	 * {@link JobStatus#ACTIVE}
	 * &lt;li&gt;{@link JobStatus#INPUT}: waiting for {@link JobStatus#INPUT} and
	 * {@link JobStatus#ACTIVE}
	 * &lt;li&gt;{@link JobStatus#ACTIVE}: waiting for {@link JobStatus#ACTIVE} only
	 * &lt;li&gt;{@link JobStatus#OUTPUT}: returning {@code true} with no checks and
	 * without waiting
	 * &lt;/ul&gt;
	 *
	 * @param job     the job to wait for
	 * @param waiting duration to wait
	 * @param timeout timeout duration
	 * @param wait    method to use for waiting
	 * @return {@code true} if the job finished and {@code false} if the timeout has
	 *         been reached
	 * @throws IOException  Technical FTP failure
	 * @throws JesException Logical JES failure
	 */
	public boolean waitFor(final Job job, final Duration waiting, final Duration timeout, final Consumer&lt;Duration&gt; wait) throws IOException, JesException {
<span class="fc bfc" id="L799" title="All 2 branches covered.">		if (job.getStatus() == JobStatus.OUTPUT) {</span>
<span class="fc" id="L800">			return true;</span>
		}
		// Status INPUT and ACTIVE might need to be waited for
<span class="fc bfc" id="L803" title="All 2 branches covered.">		final List&lt;JobStatus&gt; stati = job.getStatus() == JobStatus.ACTIVE ? singletonList(JobStatus.ACTIVE) : asList(JobStatus.INPUT, JobStatus.ACTIVE);</span>
		// Waiting for the status
<span class="fc" id="L805">		final Stopwatch stopwatch = new Stopwatch();</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">		for (final JobStatus status : stati) {</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">			while (exists(job, status)) {</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">				if (!stopwatch.waitFor(waiting, timeout, wait)) {</span>
<span class="fc" id="L809">					return false;</span>
				}
			}
<span class="fc" id="L812">		}</span>
<span class="fc" id="L813">		return true;</span>
	}

	/**
	 * FTP Client used by the current JES client instance.
	 *
	 * @return FTP client
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public FTPClient getFtpClient() {
		return this.ftpClient;
	}

	/**
	 * Current JES spool user
	 *
	 * @return JES spool owner
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public String getJesOwner() {
		return this.jesOwner;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>